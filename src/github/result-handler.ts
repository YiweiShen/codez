/**
 * Manage action results: commit changes, create pull requests, or post comments.
 */
import { promises as fs } from 'fs';
import path from 'path';
import * as core from '@actions/core';
import { execa } from 'execa';

import type { ActionConfig } from '../config/config';
import type { ProcessedEvent } from './event';
import { generateCommitMessage as generateCommitMessageOpenAI } from '../api/openai';
import { GitHubError } from '../utils/errors';
import { createPullRequest, commitAndPush } from './git';
import { upsertComment } from './comments';
// Directories to ignore when processing results
const WORKFLOWS_DIR = '.github/workflows';
const IMAGES_DIR = 'codex-comment-images';
const WORKFLOWS_PREFIX = `${WORKFLOWS_DIR}/`;
const IMAGES_PREFIX = `${IMAGES_DIR}/`;

/** Filter files by prefix */
function filesWithPrefix(files: string[], prefix: string): string[] {
  return files.filter((f) => f.startsWith(prefix));
}

/** Revert changes to workflow files via git checkout */
async function revertWorkflowFiles(workspace: string): Promise<void> {
  await execa('git', ['checkout', 'HEAD', '--', WORKFLOWS_DIR], {
    cwd: workspace,
    stdio: 'inherit',
  });
}

/** Remove generated image artifacts directory */
async function removeImageArtifacts(workspace: string): Promise<void> {
  const dir = path.join(workspace, IMAGES_DIR);
  try {
    await fs.rm(dir, { recursive: true, force: true });
    core.info(`Removed image artifacts directory: ${dir}`);
  } catch (error) {
    core.warning(
      `Failed to remove image artifacts directory: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/** Extract issue and PR numbers from processed event */
function getEventNumbers(agentEvent: ProcessedEvent['agentEvent']) {
  const { type, github: g } = agentEvent;
  const issueNumber =
    type === 'issuesOpened' || type === 'issueCommentCreated' || type === 'issuesAssigned'
      ? g.issue.number
      : undefined;
  const prNumber =
    type === 'pullRequestCommentCreated'
      ? g.issue.number
      : type === 'pullRequestReviewCommentCreated'
      ? g.pull_request.number
      : undefined;
  return { issueNumber, prNumber };
}

/**
 * Process and publish the action's results: push commits, open PR, or post comments.
 * @param config - The ActionConfig with context and clients.
 * @param processedEvent - Normalized event data triggering the action.
 * @param output - The raw text output generated by Codex or fallback.
 * @param changedFiles - List of relative file paths that were modified.
 * @param progressCommentId - Optional ID of the progress comment to update.
 * @returns Promise that resolves when result processing is complete.
 */
export async function handleResult(
  config: ActionConfig,
  processedEvent: ProcessedEvent,
  output: string,
  changedFiles: string[],
  progressCommentId?: number,
): Promise<void> {
  const { octokit, repo, workspace } = config;
  const { agentEvent, userPrompt, noPr } = processedEvent;
  const event = agentEvent.github;
  if (noPr) {
    core.info('Flag --no-pr detected; skipping pull request creation.');
  }
  // ignore workflow changes
  const workflowFiles = changedFiles.filter((f) => f.startsWith(WORKFLOWS_PREFIX));
  if (workflowFiles.length > 0) {
    core.warning(`Ignoring changes to workflow files: ${workflowFiles.join(', ')}`);
    await execa('git', ['checkout', 'HEAD', '--', WORKFLOWS_DIR], {
      cwd: workspace,
      stdio: 'inherit',
    });
  }
  // ignore generated image artifacts
  const imageFiles = changedFiles.filter((f) => f.startsWith(IMAGES_PREFIX));
  if (imageFiles.length > 0) {
    core.warning(`Ignoring changes to ${IMAGES_DIR} folder: ${imageFiles.join(', ')}`);
    await fs.rm(path.join(workspace, IMAGES_DIR), { recursive: true, force: true });
    core.info(`Removed image artifacts directory: ${path.join(workspace, IMAGES_DIR)}`);
  }
  const effectiveChangedFiles = changedFiles.filter(
    (f) => !f.startsWith(WORKFLOWS_PREFIX) && !f.startsWith(IMAGES_PREFIX),
  );

  if (!noPr && effectiveChangedFiles.length > 0) {
    core.info(
      `Detected changes in ${
        effectiveChangedFiles.length
      } files:\n${effectiveChangedFiles.join('\n')}`,
    );

    const { issueNumber, prNumber } = getEventNumbers(agentEvent);
    core.info('[perf] generateCommitMessage start');
    const startGenerateCommitMessage = Date.now();
    const commitMessage = await generateCommitMessageOpenAI(
      effectiveChangedFiles,
      userPrompt,
      { issueNumber, prNumber },
      config,
    );
    core.info(`[perf] generateCommitMessage end - ${Date.now() - startGenerateCommitMessage}ms`);

    if (
      agentEvent.type === 'issuesOpened' ||
      agentEvent.type === 'issueCommentCreated' ||
      agentEvent.type === 'issuesAssigned'
    ) {
      await createPullRequest(
        workspace,
        octokit,
        repo,
        agentEvent.github,
        commitMessage,
        output,
        progressCommentId,
      );
    } else if (
      agentEvent.type === 'pullRequestCommentCreated' ||
      agentEvent.type === 'pullRequestReviewCommentCreated'
    ) {
      await commitAndPush(
        workspace,
        octokit,
        repo,
        agentEvent.github,
        commitMessage,
        output,
        progressCommentId,
      );
    }
  } else if (noPr && effectiveChangedFiles.length > 0) {
    core.info(
      `--no-pr flag used and detected changes in ${effectiveChangedFiles.length} files; posting diff in comment.`,
    );
    let diffOutput = '';
    try {
      const { stdout } = await execa(
        'git',
        ['diff', 'HEAD', '--', ...effectiveChangedFiles],
        { cwd: workspace },
      );
      diffOutput = stdout;
    } catch (err) {
      core.warning(
        `Failed to generate diff for comment: ${
          err instanceof Error ? err.message : String(err)
        }`,
      );
    }
    const commentBody = `${output}\n\n**Proposed changes:**\n\`\`\`diff\n${diffOutput}\n\`\`\``;
    await upsertComment(octokit, repo, event, progressCommentId, commentBody);
  } else {
    await upsertComment(octokit, repo, event, progressCommentId, output);
  }
}
